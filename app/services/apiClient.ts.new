import { store } from '../store';
import { 
  refresh, 
  selectAccessToken, 
  isTokenExpiredOrExpiring, 
  selectAuthState,
  checkAndRefreshTokenIfNeeded,
  logout,
  setIsRefreshing,
  setError
} from '../features/auth/authSlice';
import directus from './directus';
import { Platform } from 'react-native';
import { getTokens, saveTokens } from './secureStorage';

// Type for request options
interface RequestOptions {
  path: string;
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  params?: Record<string, any>;
  body?: any;
  headers?: Record<string, string>;
}

// Type for request function
type RequestFunction = () => RequestOptions;

// Queue for pending requests during token refresh
let requestQueue: Array<{
  resolve: () => void;
  reject: (error: Error) => void;
}> = [];

// Maximum number of retry attempts for API requests
const MAX_REQUEST_RETRIES = 2;

/**
 * Process all queued requests after token refresh
 */
const processQueue = (error: Error | null) => {
  requestQueue.forEach((promise) => {
    if (error) {
      promise.reject(error);
    } else {
      promise.resolve();
    }
  });
  
  // Reset the queue
  requestQueue = [];
};

/**
 * Wait for token refresh to complete
 * This function checks if a refresh is in progress and waits for it to complete
 */
const waitForTokenRefresh = async (): Promise<void> => {
  const state = store.getState();
  
  if (state.auth.isRefreshing) {
    console.log(`[API] Token refresh in progress, waiting... (${Platform.OS})`);
    return new Promise<void>((resolve, reject) => {
      requestQueue.push({ resolve, reject });
    });
  }
};

/**
 * Enhanced API client wrapper that uses the centralized auth middleware for token refresh
 * This function will:
 * 1. Check if a token refresh is in progress and wait for it to complete
 * 2. Make the API call with the current token
 * 3. If the API call fails with a 401, trigger a token refresh via the auth middleware and retry once
 */
export const apiRequest = async <T>(requestFn: RequestFunction): Promise<T> => {
  // Get the current state
  const state = store.getState();
  const auth = selectAuthState(state);
  let token = auth.tokens?.accessToken;

  // If no tokens, we can't make authenticated requests
  if (!token) {
    throw new Error('No authentication tokens available');
  }
  
  // If a token refresh is in progress, wait for it to complete
  await waitForTokenRefresh();
  
  // Get the latest token after potential refresh
  token = store.getState().auth.tokens?.accessToken || token;
  
  const tryRequest = async (accessToken: string, retryCount = 0): Promise<T> => {
    try {
      // Get the request options
      const options = requestFn();
      
      // Add the authorization header if not already present
      const headers = options.headers || {};
      if (!headers['Authorization']) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      
      // Make the API call
      return await directus.request(() => ({
        ...options,
        headers
      })) as T;
    } catch (error: any) {
      // Check if the error is due to an expired token
      const isTokenError = 
        error?.response?.status === 401 || 
        error?.response?.status === 403 ||
        (error?.errors && error?.errors[0]?.message === 'Token expired.') ||
        error?.message?.includes('401') ||
        error?.message?.includes('403') ||
        error?.message?.includes('Token expired') ||
        error?.message?.includes('Invalid token');
      
      if (isTokenError && retryCount < MAX_REQUEST_RETRIES) {
        console.log(`[API] Token error during request (${retryCount + 1}/${MAX_REQUEST_RETRIES}). Refreshing... (${Platform.OS})`);
        
        try {
          // Mark that a refresh is in progress
          store.dispatch(setIsRefreshing(true));
          
          // Dispatch the refresh action
          const refreshResult = await store.dispatch(refresh()).unwrap();
          
          // Mark that refresh is complete
          store.dispatch(setIsRefreshing(false));
          
          // Process any queued requests
          processQueue(null);
          
          if (!refreshResult.tokens?.accessToken) {
            throw new Error('Failed to refresh token: No new token received');
          }
          
          console.log(`[API] Token refreshed successfully. Retrying request... (${Platform.OS})`);
          
          // Retry the request with the new token
          return await tryRequest(refreshResult.tokens.accessToken, retryCount + 1);
        } catch (refreshError: any) {
          console.error(`[API] Failed to refresh token: ${refreshError.message} (${Platform.OS})`);
          
          // Mark that refresh is complete
          store.dispatch(setIsRefreshing(false));
          
          // Process any queued requests with the error
          processQueue(refreshError);
          
          // Log the user out with a message that will be displayed in our custom Toast
          store.dispatch(logout('Authentication expired. Please log in again.'));
          
          throw new Error('Authentication expired. Please log in again.');
        }
      }
      
      // If it's not a token issue or we've exhausted retries, rethrow the original error
      if (retryCount > 0) {
        console.error(`[API] Request failed after ${retryCount} retries: ${error.message} (${Platform.OS})`);
      } else {
        console.error(`[API] Request failed: ${error.message} (${Platform.OS})`);
      }
      
      throw error;
    }
  };
  
  // Try the request with the current token
  return await tryRequest(token);
};

/**
 * Direct API request using fetch (for cases where directus SDK doesn't work well)
 * Enhanced with the same token refresh mechanism as apiRequest
 */
export const directApiRequest = async <T>(
  endpoint: string,
  method: string = 'GET',
  body?: any
): Promise<T> => {
  // Get the current state
  const state = store.getState();
  const auth = selectAuthState(state);
  let token = auth.tokens?.accessToken;
  
  // If no tokens, we can't make authenticated requests
  if (!token) {
    throw new Error('No authentication tokens available');
  }
  
  // If a token refresh is in progress, wait for it to complete
  await waitForTokenRefresh();
  
  // Get the latest token after potential refresh
  token = store.getState().auth.tokens?.accessToken || token;
  
  const tryFetch = async (accessToken: string, retryCount = 0): Promise<T> => {
    try {
      const baseUrl = process.env.EXPO_PUBLIC_API_BASE_URL || 'http://139.59.232.231:8055';
      const url = `${baseUrl}${endpoint}`;
      
      const options: RequestInit = {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`
        }
      };
      
      if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
        options.body = typeof body === 'string' ? body : JSON.stringify(body);
      }
      
      const response = await fetch(url, options);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || `Request failed with status ${response.status}`);
      }
      
      return await response.json() as T;
    } catch (error: any) {
      // Check if the error is a token expiration error
      const isTokenError = 
        error.message.includes('401') || 
        error.message.includes('403') ||
        error.message.includes('Token expired') ||
        error.message.includes('Invalid token');
      
      if (isTokenError && retryCount < MAX_REQUEST_RETRIES) {
        console.log(`[API] Token error during direct request (${retryCount + 1}/${MAX_REQUEST_RETRIES}). Refreshing... (${Platform.OS})`);
        
        try {
          // Mark that a refresh is in progress
          store.dispatch(setIsRefreshing(true));
          
          // Dispatch the refresh action
          const refreshResult = await store.dispatch(refresh()).unwrap();
          
          // Mark that refresh is complete
          store.dispatch(setIsRefreshing(false));
          
          // Process any queued requests
          processQueue(null);
          
          if (!refreshResult.tokens?.accessToken) {
            throw new Error('Failed to refresh token: No new token received');
          }
          
          console.log(`[API] Token refreshed successfully. Retrying direct request... (${Platform.OS})`);
          
          // Retry the request with the new token
          return await tryFetch(refreshResult.tokens.accessToken, retryCount + 1);
        } catch (refreshError: any) {
          console.error(`[API] Failed to refresh token: ${refreshError.message} (${Platform.OS})`);
          
          // Mark that refresh is complete
          store.dispatch(setIsRefreshing(false));
          
          // Process any queued requests with the error
          processQueue(refreshError);
          
          // Log the user out with a message that will be displayed in our custom Toast
          store.dispatch(logout('Authentication expired. Please log in again.'));
          
          throw new Error('Authentication expired. Please log in again.');
        }
      }
      
      // If it's not a token issue or we've exhausted retries, rethrow the original error
      if (retryCount > 0) {
        console.error(`[API] Direct request failed after ${retryCount} retries: ${error.message} (${Platform.OS})`);
      } else {
        console.error(`[API] Direct request failed: ${error.message} (${Platform.OS})`);
      }
      
      throw error;
    }
  };
  
  // Try the request with the current token
  return await tryFetch(token);
};

/**
 * Export a helper function to manually refresh the token
 * This can be used in components that need to ensure a fresh token
 * before making multiple API calls
 */
export const ensureFreshToken = async (): Promise<string> => {
  // First check if a refresh is already in progress
  await waitForTokenRefresh();
  
  // Get the current state
  const state = store.getState();
  const auth = selectAuthState(state);
  
  if (!auth.tokens?.accessToken) {
    throw new Error('No authentication token available');
  }
  
  // Check if token is expired or about to expire
  if (isTokenExpiredOrExpiring(auth.tokens?.expiresAt)) {
    console.log(`[API] Token is expired or about to expire, refreshing in ensureFreshToken... (${Platform.OS})`);
    
    try {
      // Mark that a refresh is in progress
      store.dispatch(setIsRefreshing(true));
      
      // Dispatch the refresh action
      const refreshResult = await store.dispatch(refresh()).unwrap();
      
      // Mark that refresh is complete
      store.dispatch(setIsRefreshing(false));
      
      // Process any queued requests
      processQueue(null);
      
      if (!refreshResult.tokens?.accessToken) {
        throw new Error('Failed to refresh token: No new token received');
      }
      
      return refreshResult.tokens.accessToken;
    } catch (error: any) {
      console.error(`[API] Failed to refresh token in ensureFreshToken: ${error.message} (${Platform.OS})`);
      
      // Mark that refresh is complete
      store.dispatch(setIsRefreshing(false));
      
      // Process any queued requests with the error
      processQueue(error);
      
      // Log the user out with a message that will be displayed in our custom Toast
      store.dispatch(logout('Authentication expired. Please log in again.'));
      
      throw new Error('Authentication expired. Please log in again.');
    }
  }
  
  return auth.tokens.accessToken;
};

/**
 * Check if tokens are valid on app startup
 * This function should be called when the app starts to validate stored tokens
 */
export const validateTokensOnStartup = async (): Promise<void> => {
  try {
    // Get tokens from secure storage
    const tokens = await getTokens();
    
    // If no tokens, nothing to validate
    if (!tokens) {
      console.log(`[API] No tokens found in secure storage on startup (${Platform.OS})`);
      return;
    }
    
    // Check if tokens are expired
    if (isTokenExpiredOrExpiring(tokens.expiresAt)) {
      console.log(`[API] Tokens in secure storage are expired on startup, attempting refresh... (${Platform.OS})`);
      
      try {
        // Try to refresh the tokens
        const refreshResult = await store.dispatch(refresh()).unwrap();
        
        if (!refreshResult.tokens?.accessToken) {
          throw new Error('Failed to refresh token: No new token received');
        }
        
        console.log(`[API] Tokens refreshed successfully on startup (${Platform.OS})`);
      } catch (error: any) {
        console.error(`[API] Failed to refresh tokens on startup: ${error.message} (${Platform.OS})`);
        
        // Clear tokens and log out with a message that will be displayed in our custom Toast
        store.dispatch(logout('Your session has expired. Please log in again.'));
      }
    } else {
      console.log(`[API] Tokens in secure storage are valid on startup (${Platform.OS})`);
    }
  } catch (error: any) {
    console.error(`[API] Error validating tokens on startup: ${error.message} (${Platform.OS})`);
  }
};

export default apiRequest;